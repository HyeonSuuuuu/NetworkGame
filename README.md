# TCP-
전송계층

TCP - 데이터가 순대로 도착하는것을 보장한다

ISN, ACK 메커니즘을 사용한다.

ISN - Initial Sequence Number, ACK - 확인응답

![Screenshot_20250807-230111~2](https://github.com/user-attachments/assets/d7241889-f7a7-4d9e-9691-dbaef71f8624)
[멀티플레이어 게임 프로그래밍/산제이 마드하브 및 죠슈아 글레이저/128p]

**발신자 / 수신자 포트(16비트/16비트)** : 프로세스 구분을 위한 16비트 부호없는 정수로(0~65535) 0~1023까지는 시스템 포트, 1024~49151까진 사용자 포트로 IANA 기구 산하 ICANN 부서에선 포 번호 등록제를 운영하여 포트를 동록해 사용하게 권장한다. , 49152~65535까진 동적 포트로 IANA 관할 밖이다. 어느 프로세스가 쓰든 제약이 없어 비어있는 프로그램을 찾을 때까지 동적 포트에 바인딩을 시도하여 자동으로 잡을 수도 있다

**시퀸스 번호(32비트)**: TCP에서 식별자로 쓰이며 ISN 생성 방식은 운영체제에서 임의의 난수를 사용해 생성한다.

**ACK 번호(32비트)** : 발신자가 응답받기를 기다리는 다음 시퀸스 번호이다.

**데이터 오프셋 (4비트):** 헤더 길이를 32비트(4바이트) 워드로 저장한다. 즉 데이터 오프셋이 5이면 5 * 4 = 20바이트의 헤더 길이를 나타낸다.

**제어비트(9비트)** : 메타 정보 플래그, SYN 플래그, ACK 플래그도 여기에 포함된다.

**수신 윈도(16비트)** : 발신자가 데이터 전송에 사용하는 버퍼 용량이 얼마나 남은지 알려준다. (흐름제어에 사용)

**체크섬 (16비트)** : 데이터가 변형되었는지 검사한다.

호스트 A와 B 사이의 TCP 통신을 위해 3way handshaking 과정으로 서로의 시퀸스 번호를 주고받는다.
![Screenshot_20250807-230935~2](https://github.com/user-attachments/assets/746b710f-bb13-47e2-94d8-392f8d3e08ed)
[멀티플레이어 게임 프로그래밍/산제이 마드하브 및 죠슈아 글레이저/132p]

3way handshaking 과정

1. 호스트 A는 임의의 난수(여기선 1000)를 시퀸스 번호로 설정하여 SYN 플래그를 셋하고 호스트 B에 보낸다. 
2. 호스트B도 임의의 난수(여기선 3000)을 시퀸스 넘버로 설정하여 SYN 플래그와 ACK 플래그를 둘다 셋하고 ACK 번호엔 호스트 A의 시퀸스 번호 + 1로 하고 호스트 A에 보낸다.
3. 호스트 A는 시퀸스 번호 +1을 한 후 ACK에 호스트 B의 시퀸스 번호 + 1를 보내고 ACK를 셋하여 호스트 B에 보낸다.

이 과정에 끝나면 호스트 A, B는 서로의 시퀸스 번호를 알게 되고 데이터를 주고받을 수 있다.
<img width="1261" height="773" alt="Screenshot_20250807-235417-display-0 png" src="https://github.com/user-attachments/assets/6927a11b-ca14-4f28-b908-8b2768b85e47" />
[멀티플레이어 게임 프로그래밍/산제이 마드하브 및 죠슈아 글레이저/136p]

데이터 전송 과정

Ack에는 다음번 받아야할 시퀸스 번호를 기재하는데 항상 마지막으로 받은 시퀸스 번호 + 데이터 길이이다.

서로 이렇게 주고받다가 보낼 데이터가 없어지면 0의 길이로 보낸다.

만약 응답을 못받는다면 다시 보내는데 여기서 중요한점은 TCP 모듈은 데이터를 모두 보낸 것을 확인응답 받기까지 데이터를 들고 있다. 즉, 잘 받았다는 ACK를 받은 후에야 이 데이터를 메모리에서 제거할 수 있다.

또한 순서도 보장되는데 만약 내가 가지고 있는 Ack번호보다 받은 시퀸스 번호가 더 크다면 임시 저장해놨다가 앞에 것이 다 채워지면 저장해놓은걸 꺼내서 처리하고 마지막 ACK를 넘긴다.

이더넷의 MTU가 1500 바이트라면 IPv4 최소 헤더 20바이트, TCP 20바이트를 뺴면 1460바이트가 되는데 이를 MSS(Maximun segment size)라고 한다.

TCP는 흐름 제어

빠른 송신 호스트가 느린 수신 호스트를 압도하지 못하게 제어하는 기법이다. (만약 이게 없다면 엄청난 체증이 유발되어 막대한 인터넷 자원이 낭비된다. - 수신측이 송신측 속도를 못따라가면 수신측 버퍼가 가득차게 되고 데이터는 버려진다.  송신측은 ACK를 받지 못해 수신측에 계속 재전송하게 되는데 수신측은 가득찬 버퍼를 처리하기 바쁘다. 결국 송신측이 보낸 데이터가 또다시 버려지고 엄청난 낭비가 발생한다.)

이를 위해 수신 윈도 필드란게 있고 남은 버퍼량을 기재한다. 이를 보고 얼마 안남았다면 ACK를 기다렸다 보내게 된다.
<img width="1159" height="1332" alt="Screenshot_20250808-100952-display-0 png" src="https://github.com/user-attachments/assets/8f9ce54b-3a25-4c48-8840-6a60ed010244" />
[멀티플레이어 게임 프로그래밍/산제이 마드하브 및 죠슈아 글레이저/143p]

흐름 제어 방법

1. 3way handshaking을 하며 윈도(남은 버퍼량)도 같이 알려준다 (여기선 300을 알려줬다)
2. 윈도 크기만큼 데이터를 보낸다 (여기선 길이 100으로 3번 보냈다)
3. 호스트 B는 ACK를 A에게 보낸다 (이 예제에선 지연 ACK 규정을 따르지 않아 일일이 ACK를 보내고 있다)
4. 호스트 A는 호스트 B에게 ACK를 받는데 보낸 데이터의 100을 처리 못했고 남은 윈도가 150이므로 50의 여유가 있단것을 계산하여 50의 데이터를 더 보낸다.

보다싶이 호스트 B는 Ack 패킷을 여러번 보내는데 첫번쨰 Ack는  두번째 Ack만 봐도 알 수 있는 정보이므로 안보내도 되는걸 알 수 있다. 이를 위해 TCP에는 지연 ACK라는 규정이 있다. 명세서에 따르면 TCP 세그먼트를 받은 호스트는 즉답 응답할 필요가 없으며 최대 500밀리초까지 기다려보고 시간 내에 다음 세그먼트가 오지 않은 경우에만 ACK를 보내도 상관없다.

TCP엔 혼잡제어도 있는데 신호등과 비슷하다. 대부분 합증가/곱감소에서 파생된 기법을 사용한다. 보통 MSS의 2배 크기의 임계치를 잡고 패킷이 누락될때까지 임계치에 MSS만큼 더한다. 만일 하나라도 누락되면 임계치를 절반으로 줄인다.  이런식으로 조절해나가면 점차 적절히 안정된 수치로 수렴하며 체증으로 인해 패킷이 누락되지 않을 만큼의 적당한 빠르기로 패킷을 보낼 수 있게 된다.

패킷 크기를 최대 세그먼트 길이에 가능한 가깝게 맞춰 네트워크 혼잡을 줄이는 기법도 있다. 각 패킷엔 40바이트 헤더( IP 최소 헤더 20바이트 + TCP 최소 헤더 20바이트)가 붙어야 하므로 큰 세그먼트 하나로 합쳐 보내는게 유리하다. 여러 운영체제에선 네이글 알고리즘을 적용해 세그먼트를 보내기 전 데이터를 쌓아두도록 규정한다. (보통 MSS와 혼잡 제어 임계치중 작은 값으로 한다) 

하지만 네이글 알고리즘은 지연시간을 희생해 대역폭을 높이는 기법이기 때문에 지연시간이 중요한 게임에선 네이글 알고리즘을 비활성화 한다. (요즘은 대역폭이 크기 때문에 지연시간을 최우선으로 한다)

TCP 상태 제어 (3way handshaking 진행 단계에 따라 구분한다)

LISTEN - 서버가 클라이언트 연결 요청을 기다리는 상태, TCP 연결 요청(SYN 패킷)을 수신하기 전 단계

SYN-SENT  - 클라이언트가 서버에 SYN 패킷을 보내고 SYN+ACK 패킷을 기다리는 상태

SYN-RECEIVE - 서버가 클라이언트에 SYN+ACK패킷을 보내고 ACK 패킷을 기다리는 상태

ESTABLISHED - 3way handshaking이 끝나고 데이터 전송이 가능한 상태

각 상태별 타임아웃 처리 및 재시도 전략이 필요하다.

Socket 백로그 Queue

1. SYN 큐
클라이언트가 SYN 패킷을 보내고 서버가 SYN-ACK로 응답했지만 클라이언트의 최종 ACK를 아직 못받은 상태의 연결들, 즉 SYN-RECEIVE 상태의 연결들이 저장된다.
2. Accept 큐
    
    3-way handshake가 완료된 연결들이 저장되는 큐로 서버에서 accept() 시스템 콜을 호출할 때까지 이 큐에서 대기
